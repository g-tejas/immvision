#include "immvision/image.h"
#include "immvision/internal/misc/immvision_to_string.h"
#include "cvnp/cvnp.h"
#include "transfer_imgui_context.h"

#include <opencv2/core.hpp>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>


namespace py = pybind11;



void pydef_image(pybind11::module& m)
{
    using namespace ImmVision;

    // <autogen:pydef_struct> // Autogenerated code below! Do not edit!

    auto pyClassColormapScaleFromStatsData = py::class_<ColormapScaleFromStatsData>(m, "ColormapScaleFromStatsData", 
        R"DocString(Scale the Colormap according to the Image  stats)DocString")
        .def(py::init<>()) 
        .def_readwrite("active_on_full_image", &ColormapScaleFromStatsData::ActiveOnFullImage, "Are we using the stats on the full image?\nIf ActiveOnFullImage and ActiveOnROI are both false, then ColormapSettingsData.ColormapScaleMin/Max will be used")
        .def_readwrite("active_on_roi", &ColormapScaleFromStatsData::ActiveOnROI, "Are we using the stats on the ROI?\nIf ActiveOnFullImage and ActiveOnROI are both false, then ColormapSettingsData.ColormapScaleMin/Max will be used\nNote: ActiveOnROI and ActiveOnFullImage cannot be true at the same time!")
        .def_readwrite("nb_sigmas", &ColormapScaleFromStatsData::NbSigmas, "If active (either on ROI or on Image), how many sigmas around the mean should the Colormap be applied")
        .def_readwrite("use_stats_min", &ColormapScaleFromStatsData::UseStatsMin, "If UseStatsMin is true, then ColormapScaleMin will be calculated from the matrix min value instead of a sigma based value")
        .def_readwrite("use_stats_max", &ColormapScaleFromStatsData::UseStatsMax, "If UseStatsMin is true, then ColormapScaleMax will be calculated from the matrix max value instead of a sigma based value")
        .def("__repr__", [](const ColormapScaleFromStatsData& v) { return ToString(v); }); 

    auto pyClassColormapSettingsData = py::class_<ColormapSettingsData>(m, "ColormapSettingsData", 
        R"DocString(Colormap Settings (useful for matrices with one channel, in order to see colors mapping float values))DocString")
        .def(py::init<>()) 
        .def_readwrite("colormap", &ColormapSettingsData::Colormap, "Colormap, see available Colormaps with AvailableColormaps()\nWork only with 1 channel matrices, i.e len(shape)==2")
        .def_readwrite("colormap_scale_min", &ColormapSettingsData::ColormapScaleMin, "ColormapScaleMin and ColormapScaleMax indicate how the Colormap is applied:\n- Values in [ColormapScaleMin, ColomapScaleMax] will use the full colormap.\n- Values outside this interval will be clamped before coloring\nby default, the initial values are ignored, and they will be updated automatically\nvia the options in ColormapScaleFromStats")
        .def_readwrite("colormap_scale_max", &ColormapSettingsData::ColormapScaleMax, "")
        .def_readwrite("colormap_scale_from_stats", &ColormapSettingsData::ColormapScaleFromStats, "If ColormapScaleFromStats.ActiveOnFullImage or ColormapScaleFromStats.ActiveOnROI,\nthen ColormapScaleMin/Max are ignored, and the scaling is done according to the image stats.\nColormapScaleFromStats.ActiveOnFullImage is true by default")
        .def_readwrite("internal_colormap_hovered", &ColormapSettingsData::internal_ColormapHovered, "Internal value: stores the name of the Colormap that is hovered by the mouse")
        .def("__repr__", [](const ColormapSettingsData& v) { return ToString(v); }); 

    auto pyClassMouseInformation = py::class_<MouseInformation>(m, "MouseInformation", 
        R"DocString(Contains information about the mouse inside an image)DocString")
        .def(py::init<>()) 
        .def_readwrite("is_mouse_hovering", &MouseInformation::IsMouseHovering, "Is the mouse hovering the image")
        .def_readwrite("mouse_position", &MouseInformation::MousePosition, "Mouse position in the original image/matrix\nThis position is given with float coordinates, and will be (-1., -1.) if the mouse is not hovering the image")
        .def_readwrite("mouse_position_displayed", &MouseInformation::MousePosition_Displayed, "Mouse position in the displayed portion of the image (the original image can be zoomed,\nand only show a subset if it may be shown).\nThis position is given with integer coordinates, and will be (-1, -1) if the mouse is not hovering the image")
        //  Note: you can query ImGui::IsMouseDown(mouse_button) (c++) or imgui.is_mouse_down(mouse_button) (Python)
        .def("__repr__", [](const MouseInformation& v) { return ToString(v); }); 

    auto pyClassImageParams = py::class_<ImageParams>(m, "ImageParams", 
        R"DocString(Set of display parameters and options for an Image)DocString")
        .def(py::init<>()) 
        //  ImageParams store the parameters for a displayed image
        //  (as well as user selected watched pixels, selected channel, etc.)
        //  Its default constructor will give them reasonable choices, which you can adapt to your needs.
        //  Its values will be updated when the user pans or zooms the image, adds watched pixels, etc.
        //  Refresh Images Textures
        .def_readwrite("refresh_image", &ImageParams::RefreshImage, "Refresh Image: images textures are cached. Set to true if your image matrix/buffer has changed\n(for example, for live video images)")
        //  Display size and title
        .def_readwrite("image_display_size", &ImageParams::ImageDisplaySize, "Size of the displayed image (can be different from the matrix size)\nIf you specify only the width or height (e.g (300, 0), then the other dimension\nwill be calculated automatically, respecting the original image w/h ratio.")
        //  Zoom and Pan (represented by an affine transform matrix, of size 3x3)
        .def_readwrite("zoom_pan_matrix", &ImageParams::ZoomPanMatrix, "ZoomPanMatrix can be created using MakeZoomPanMatrix to create a view centered around a given point")
        .def_readwrite("zoom_key", &ImageParams::ZoomKey, "If displaying several images, those with the same ZoomKey will zoom and pan together")
        //  Colormap Settings (useful for matrices with one channel, in order to see colors mapping float values)
        .def_readwrite("colormap_settings", &ImageParams::ColormapSettings, "ColormapSettings stores all the parameter concerning the Colormap")
        .def_readwrite("colormap_key", &ImageParams::ColormapKey, "If displaying several images, those with the same ColormapKey will adjust together")
        //  Zoom and pan with the mouse
        .def_readwrite("pan_with_mouse", &ImageParams::PanWithMouse, "")
        .def_readwrite("zoom_with_mouse_wheel", &ImageParams::ZoomWithMouseWheel, "")
        .def_readwrite("is_color_order_bgr", &ImageParams::IsColorOrderBGR, "Color Order: RGB or RGBA versus BGR or BGRA (Note: by default OpenCV uses BGR and BGRA)")
        //  Image display options
        .def_readwrite("selected_channel", &ImageParams::SelectedChannel, "if SelectedChannel >= 0 then only this channel is displayed")
        .def_readwrite("show_school_paper_background", &ImageParams::ShowSchoolPaperBackground, "Show a \"school paper\" background grid")
        .def_readwrite("show_alpha_channel_checkerboard", &ImageParams::ShowAlphaChannelCheckerboard, "show a checkerboard behind transparent portions of 4 channels RGBA images")
        .def_readwrite("show_grid", &ImageParams::ShowGrid, "Grid displayed when the zoom is high")
        .def_readwrite("draw_values_on_zoomed_pixels", &ImageParams::DrawValuesOnZoomedPixels, "Pixel values show when the zoom is high")
        //  Image display options
        .def_readwrite("show_image_info", &ImageParams::ShowImageInfo, "Show matrix type and size")
        .def_readwrite("show_pixel_info", &ImageParams::ShowPixelInfo, "Show pixel values")
        .def_readwrite("show_zoom_buttons", &ImageParams::ShowZoomButtons, "Show buttons that enable to zoom in/out (the mouse wheel also zoom)")
        .def_readwrite("show_options_panel", &ImageParams::ShowOptionsPanel, "Open the options panel")
        .def_readwrite("show_options_in_tooltip", &ImageParams::ShowOptionsInTooltip, "If set to true, then the option panel will be displayed in a transient tooltip window")
        .def_readwrite("show_options_button", &ImageParams::ShowOptionsButton, "If set to false, then the Options button will not be displayed")
        //  Watched Pixels
        .def_readwrite("watched_pixels", &ImageParams::WatchedPixels, "List of Watched Pixel coordinates")
        .def_readwrite("add_watched_pixel_on_double_click", &ImageParams::AddWatchedPixelOnDoubleClick, "Shall we add a watched pixel on double click")
        .def_readwrite("highlight_watched_pixels", &ImageParams::HighlightWatchedPixels, "Shall the watched pixels be drawn on the image")
        .def_readwrite("mouse_info", &ImageParams::MouseInfo, "Mouse position information. These values are filled after displaying an image")
        .def("__repr__", [](const ImageParams& v) { return ToString(v); }); 


        // </autogen:pydef_struct> // Autogenerated end


        // <autogen:pydef_function> // Autogenerated code below! Do not edit!

        m.def("factor_image_params_display_only", ImmVision::FactorImageParamsDisplayOnly, "Create ImageParams that display the image only, with no decoration, and no user interaction");
        m.def("make_zoom_pan_matrix", ImmVision::MakeZoomPanMatrix, "Create a zoom/pan matrix centered around a given point of interest");
        m.def("image", ImmVision::Image, "Display an image, with full user control: zoom, pan, watch pixels, etc.\n\n :param label_id\n     A legend that will be displayed.\n     Important notes:\n         - With ImGui and ImmVision, widgets must have a unique Ids.\n           For this widget, the id is given by this label.\n           Two widgets (for example) two images cannot have the same label or the same id!\n\n           If they do, they might not refresh correctly!\n           To circumvent this, you can:\n              - Call `ImGui::PushID(\"some_unique_string\")` at the start of your function,\n                and `ImGui::PopID()` at the end.\n              - Or modify your label like this:\n                  \"MyLabel##some_unique_id\"\n                  (the part after \"##\" will not be displayed but will be part of the id)\n        - To display an empty legend, use \"##_some_unique_id\"\n\n :param mat\n     An image you want to display, under the form of an OpenCV matrix. All types of dense matrices are supported.\n\n :param params\n     Complete options (as modifiable inputs), and outputs (mouse position, watched pixels, etc)\n     @see ImageParams structure.\n     The ImageParams may be modified by this function: you can extract from them\n     the mouse position, watched pixels, etc.\n     Important note:\n         ImageParams is an input-output parameter, passed as a pointer.\n         Its scope should be wide enough so that it is preserved from frame to frame.\n         !! If you cannot zoom/pan in a displayed image, extend the scope of the ImageParams !!\n\n - This function requires that both imgui and OpenGL were initialized.\n   (for example, use `imgui_runner.run`for Python,  or `HelloImGui::Run` for C++)");
        m.def("image_display", ImmVision::ImageDisplay, "Only, display the image, with no decoration, and no user interaction (by default)\n\n Parameters:\n :param label\n     A legend that will be displayed.\n     Important notes:\n         - With ImGui and ImmVision, widgets must have a unique Ids. For this widget, the id is given by this label.\n           Two widgets (for example) two images cannot have the same label or the same id!\n           If they do, they might not refresh correctly!\n           To circumvent this, you can modify your label like this:\n              \"MyLabel##some_unique_id\"    (the part after \"##\" will not be displayed but will be part of the id)\n        - To display an empty legend, use \"##_some_unique_id\"\n\n :param Mat:\n     An image you want to display, under the form of an OpenCV matrix. All types of dense matrices are supported.\n\n :param imageDisplaySize:\n     Size of the displayed image (can be different from the mat size)\n     If you specify only the width or height (e.g (300, 0), then the other dimension\n     will be calculated automatically, respecting the original image w/h ratio.\n\n :param refreshImage:\n     images textures are cached. Set to True if your image matrix/buffer has changed\n     (for example, for live video images)\n\n :param showOptionsButton:\n     If True, show an option button that opens the option panel.\n     In that case, it also becomes possible to zoom  pan, add watched pixel by float-clicking, etc.\n\n :param isBgrOrBgra:\n     set to True if the color order of the image is BGR or BGRA (as in OpenCV, by default)\n\n :return:\n      The mouse position in `mat` original image coordinates, as float values.\n      (i.e. it does not matter if imageDisplaySize is different from mat.size())\n      It will return (-1., -1.) if the mouse is not hovering the image.\n\n      Note: use ImGui::IsMouseDown(mouse_button) (C++) or imgui.is_mouse_down(mouse_button) (Python)\n            to query more information about the mouse.\n\n Note: this function requires that both imgui and OpenGL were initialized.\n       (for example, use `imgui_runner.run`for Python,  or `HelloImGui::Run` for C++)");
        m.def("available_colormaps", ImmVision::AvailableColormaps, "Return the list of the available color maps\n Taken from https://github.com/yuki-koyama/tinycolormap, thanks to Yuki Koyama");
        m.def("clear_texture_cache", ImmVision::ClearTextureCache, "Clears the internal texture cache of immvision (this is done automatically at exit time)\n\n Note: this function requires that both imgui and OpenGL were initialized.\n       (for example, use `imgui_runner.run`for Python,  or `HelloImGui::Run` for C++)");
        m.def("version_info", ImmVision::VersionInfo, "Return immvision version info");

        // </autogen:pydef_function> // Autogenerated code end

}