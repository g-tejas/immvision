import re
import typing
from dataclasses import dataclass

def to_snake_case(name):
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('__([A-Z])', r'_\1', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def to_camel_case(name):
    r = ''.join(word.title() for word in name.split('_'))
    return r


@dataclass
class StringReplacement:
    replace_what: str = ""
    by_what: str = ""


def parse_string_replacement(line: str) -> StringReplacement:
    """
    Parses a string of the form
    cv::Matx33d::eye() -> np.eye(3)
    """
    items = line.split("->")
    r = StringReplacement()
    r.replace_what = items[0].strip()
    r.by_what = items[1].strip()
    return r


def parse_string_replacements(lines: str) -> typing.List[StringReplacement]:
    lines_vec = lines.split("\n")
    lines_vec = list(lines_vec)
    lines_vec = map(lambda s: s.strip(), lines_vec)
    lines_vec = list(lines_vec)
    lines_vec = filter(lambda s: len(s) > 0, lines_vec)
    lines_vec = list(lines_vec)
    r = list( map(parse_string_replacement, lines_vec) )
    return r


def _opencv_replacements() -> typing.List[StringReplacement]:
    replacements = """
    cv::Size() -> (0, 0)
    cv::Matx33d::eye() -> np.eye(3)
    cv::Matx33d -> np.array((3, 3), np.float64)    
    cv::Size -> (w,h)
    std::string() -> ""
    std::string -> str
    true -> True
    false -> False
    """
    return parse_string_replacements(replacements)


def apply_one_replacement(s: str, replacement: StringReplacement) -> str:
    r, nb = re.subn(r'\b' + replacement.replace_what + r'\b', replacement.by_what , s)
    return r


def apply_opencv_replacements(s: str) -> str:
    r = s
    for replacement in _opencv_replacements():
        r = apply_one_replacement(r, replacement)
    return r


def test_replacement():
    s = "zoom_pan_matrix: cv::Matx33d = cv::Matx33d::eye()"
    print(apply_one_replacement(s, StringReplacement("cv::Matx33d", "blah")))


def read_text_file(filename: str) -> str:
    with open(filename, "r") as f:
        txt = f.read()
    return txt


def write_text_file(filename: str, content: str):
    with open(filename, "w") as f:
        f.write(content)


def indent_code(code: str, indent_size: int):
    lines = code.split("\n")
    indent_str = " " * indent_size
    lines = map(lambda s: indent_str + s, lines)
    return "\n".join(lines)


def write_code_between_markers(
        inout_filename: str,
        code_marker: str,
        code_to_insert: str
    ):
    code_marker_in = f"<autogen:{code_marker}>"
    code_marker_out = f"</autogen:{code_marker}>"

    input_code = read_text_file(inout_filename)
    input_code_lines = input_code.split("\n")

    output_code = ""
    is_inside_autogen_region = False
    for code_line in input_code_lines:
        if code_marker_in in code_line:
            if is_inside_autogen_region:
                raise RuntimeError(f"Encountered more than one code_marker: {code_marker_in}")
            else:
                is_inside_autogen_region = True
                indent_size = 0
                while indent_size < len(code_line) and code_line[indent_size] == " ":
                    indent_size += 1
                output_code = output_code + code_line + "\n"
                output_code = output_code + "\n\n"
                output_code = output_code + indent_code(code_to_insert, indent_size)
        else:
            if not is_inside_autogen_region:
                output_code = output_code + code_line + "\n"
            else:
                pass # Skip code lines that were already in the autogenerated region
        if code_marker_out in code_line:
            output_code = output_code + "\n\n"
            output_code = output_code + code_line + "\n"
            is_inside_autogen_region = False

    write_text_file(inout_filename, output_code)
