"""
This file generates the autogenerated code in some cpp and pyi files.

Search for occurrences of
<autogen:ImageParams.attributes>
<autogen:ImageParams.tostring>
etc.
"""
import os
import typing
from dataclasses import dataclass, field


import code_utils


THIS_DIR = os.path.dirname(__file__)
REPO_DIR = os.path.realpath(THIS_DIR + "/../..")


@dataclass
class StructCode:
    struct_name: str = ""
    line_start: int = 0      # starting line of the struct in the whole code
    line_end: int = 0        # end line of the struct
    body_code: str = ""      # the code inside the struct body
    one_line_title: str = "" # the short title just one line before the struct declaration


@dataclass
class StructAttribute:
    name_cpp: str = ""
    name_python: str = ""
    type: str = ""
    default_value: str = ""
    comment: str = ""
    line_number: int = 0  # from the body_code line_start


@dataclass
class CodeRegionComment:
    """
    A CodeRegionComment is the beginning kind of "code region" inside a struct.
    It should look like this in the C++ header file:

    `````cpp
    //
    // Display size and title                                                <=== This is a CodeRegionComment
    // (the display size can differ from the image size)                     <=== It can span several lines
    //

    // Size of the displayed image (can be different from the matrix size)   <=== This is StructAttribute.comment
    cv::Size ImageDisplaySize = cv::Size();                                   (it should fit on one line)
    // Title displayed in the border
    std::string Legend = "Image";
    ````

    """
    comment: str = ""
    line_number: int = 0


@dataclass
class Variant_Attribute_CodeRegion:
    line_number: int = 0
    code_region_comment: CodeRegionComment = None
    struct_attribute: StructAttribute = None


class StructInfos:
    def __init__(self):
        self.struct_code: StructCode = None
        self.attr_and_regions = []
    def struct_name(self):
        return self.struct_code.struct_name


def _extract_struct_code(whole_file_code: str, struct_name: str) -> StructCode:
    """
    Very dumb code parser
    :return:
    * an extract of the code, which is the body of the struct
    * the line number where it starts
    """
    r = StructCode()
    r.struct_name = struct_name

    code_lines = whole_file_code.split("\n")

    def extract_one_line_title(line_number: int):
        if line_number == 0:
            return ""
        previous_line = code_lines[line_number - 1]
        if previous_line.strip().startswith("//"):
            return previous_line.strip()[2:].strip()
        return ""

    struct_lines = []
    in_struct = False
    nb_accolades = 0
    for line_number, code_line in enumerate(code_lines):
        if f"struct {struct_name}" in code_line:
            in_struct = True
            r.line_start = line_number
            r.one_line_title = extract_one_line_title(line_number)

        if "{" in code_line and in_struct:
            nb_accolades += 1

        if "}" in code_line and in_struct:
            nb_accolades -= 1
            if nb_accolades == 0:
                if in_struct:
                    r.line_end = line_number
                in_struct = False

        if nb_accolades > 0 and in_struct:
            struct_lines.append(code_line)

    if struct_lines[0].strip() == "{":
        struct_lines = struct_lines[1:]

    r.body_code = "\n".join(struct_lines)
    return r


def extract_struct_attributes(struct_code: StructCode) -> typing.List[StructAttribute]:
    """
    *Very* dumb parser, that works with our simple structs
    """
    code_lines = struct_code.body_code.split("\n")
    code_lines = map(lambda s: s.strip(), code_lines)
    numbered_code_lines = list(enumerate(code_lines))

    def is_attribute_line(nb_and_code_line) -> bool:
        code_line = nb_and_code_line[1]
        if code_line.startswith("//") or len(code_line) == 0:
            return False
        return True

    def parse_attribute(nb_and_code_line) -> StructAttribute:
        """
        Can handle lines like
            ColorAdjustmentsValues ColorAdjustments = ColorAdjustmentsValues();
        or
            std::vector <cv::Point> WatchedPixels;
        """
        line_number = nb_and_code_line[0]
        code_line = nb_and_code_line[1]

        r = StructAttribute()
        r.line_number = line_number
        code_line = code_line.strip()
        if code_line[-1] == ";":
            code_line = code_line[:-1]
        if "=" in code_line:
            equal_sides = code_line.split("=")
            r.default_value = equal_sides[1].strip()
            code_line = equal_sides[0].strip()
        if " " not in code_line:
            raise RuntimeError(f"can't parse attribute at line {code_line}")
        last_space_pos = code_line.rindex(" ")
        r.type = code_line[:last_space_pos].strip()
        r.name_cpp = code_line[last_space_pos:].strip()
        r.name_python = code_utils.to_snake_case(r.name_cpp)
        return r

    def add_attribute_comment(attribute: StructAttribute) -> str:
        # Search for comment beginning with // immediately on top of the attribute
        comment_lines_before_attribute_decl = []
        line_number = attribute.line_number - 1
        while line_number >= 0:
            previous_code_line: str = numbered_code_lines[line_number][1]
            if not previous_code_line.startswith("//"):
                break
            previous_code_line = previous_code_line[2:].strip()
            if len(previous_code_line) == 0:
                break
            comment_lines_before_attribute_decl.append(previous_code_line)
            line_number = line_number - 1
        comment_lines_before_attribute_decl = list(reversed(comment_lines_before_attribute_decl))
        attribute.comment = "\n".join(comment_lines_before_attribute_decl)
        # if no comment found on top, try to find one to the right? (YAGNI, this is a *simple* parser)

    attribute_lines = list(filter(is_attribute_line, numbered_code_lines))
    all_attributes = list(map(parse_attribute, attribute_lines))
    for attribute in all_attributes:
        add_attribute_comment(attribute)
    return all_attributes


def extract_code_region_comments(struct_code: StructCode) -> typing.List[CodeRegionComment]:
    """
    Code region comments look like this
    //
    // This is a code region comment.
    // It can have several lines, but needs to have an empty comment before and after
    //
    """
    code_lines = struct_code.body_code.split("\n")
    code_lines = map(lambda s: s.strip(), code_lines)
    numbered_code_lines = list(enumerate(code_lines))

    all_code_region_comments = []

    def get_code_line(line_number: int) -> str:
        return numbered_code_lines[line_number][1]

    def is_empty_comment(line_number):
        return get_code_line(line_number).strip() == "//"

    def is_filled_comment(line_number):
        c = get_code_line(line_number)
        return c.strip().startswith("//") and len(c[2:].strip()) > 0

    def get_filled_comment(line_number):
        assert (is_filled_comment(line_number))
        c = get_code_line(line_number)
        return c.strip()[2:]

    def append_line(str1, str2):
        if len(str1) == 0:
            return str2
        else:
            return str1 + "\n" + str2

    current_code_region_comment = None
    for line_number, code_line in numbered_code_lines:
        if is_empty_comment(line_number) and current_code_region_comment is None:
            current_code_region_comment = CodeRegionComment()
            current_code_region_comment.line_number = line_number
        elif is_empty_comment(line_number) and current_code_region_comment is not None:
            all_code_region_comments.append(current_code_region_comment)
            current_code_region_comment = None
        elif is_filled_comment(line_number) and current_code_region_comment is not None:
            current_code_region_comment.comment = \
                append_line(current_code_region_comment.comment, get_filled_comment(line_number))

    return all_code_region_comments


def extract_struct_infos(whole_code: str, struct_name: str) -> StructInfos:
    r = StructInfos()
    r.struct_code = _extract_struct_code(whole_code, struct_name)
    struct_attributes = extract_struct_attributes(r.struct_code)
    code_region_comments = extract_code_region_comments(r.struct_code)
    for sa in struct_attributes:
        v = Variant_Attribute_CodeRegion()
        v.line_number = sa.line_number
        v.struct_attribute = sa
        r.attr_and_regions.append(v)
    for cr in code_region_comments:
        v = Variant_Attribute_CodeRegion()
        v.line_number = cr.line_number
        v.code_region_comment = cr
        r.attr_and_regions.append(v)

    r.attr_and_regions = sorted(r.attr_and_regions, key=lambda x: x.line_number)
    return r


def make_struct_doc(struct_infos: StructInfos) -> str:
    doc = f"{struct_infos.struct_code.one_line_title}\n\n"

    for info in struct_infos.attr_and_regions:
        if info.code_region_comment is not None:
            doc = doc + "\n" + info.code_region_comment.comment + "\n"
        elif info.struct_attribute is not None:
            attr = info.struct_attribute
            attr_doc = f"{attr.name_python}: {attr.type}"
            if len(attr.default_value) > 0:
                attr_doc = attr_doc + " = " + attr.default_value

            if len(attr.comment) > 0:
                comment_lines = attr.comment.split("\n")
                comment_lines = map(lambda l: "            " + l, comment_lines)
                comment = "\n".join(comment_lines)
                attr_doc = attr_doc + "\n" + comment
            doc = doc + "    * " + attr_doc + "\n"

    doc = code_utils.apply_code_replacements(doc)
    return doc


def make_struct_doc_code(struct_infos: StructInfos) -> str:
    code = f'{struct_infos.struct_name()}.__doc__ = """{make_struct_doc(struct_infos)}"""'
    return code


def make_struct_attributes_cpp_code(struct_infos: StructInfos):
    r = ""

    def add_line(l):
        nonlocal r
        r = r + l + "\n"

    for info in struct_infos.attr_and_regions:
        if info.struct_attribute is not None:
            #   .def_readwrite("ImageDisplaySize", &ImageParams::ImageDisplaySize, "The Size")
            attr = info.struct_attribute
            line = f'.def_readwrite("{attr.name_python}", &{struct_infos.struct_name()}::{attr.name_cpp}, "{attr.comment}")'
            add_line(line)
    return r


def make_struct_tostring_cpp_code(struct_infos: StructInfos):
    code_intro = f'''
        using namespace ImmVision::StringUtils;

        std::string r;
        r += "ImageParams\\n";
        r += "{{\\n";

        std::string inner;
    '''

    code_inner = 'inner = inner + "ATTR_NAME: " + ToString(v.ATTR_NAME_CPP) + "\\n";'

    code_outro = f'''
        r = r + IndentLines(inner, 4);
        r += "}}";
        return r;
    '''


    def dump_attributes(is_python: bool):
        code = ""
        for info in struct_infos.attr_and_regions:
            if info.struct_attribute is not None:
                #         r = r + MakeIndent(indent_size) + "ColorAdjustments: " + ToString(v.ColorAdjustments) + "\n";
                attr = info.struct_attribute
                line = code_inner
                line = line.replace("ATTR_NAME_CPP", attr.name_cpp)
                if is_python:
                    line = line.replace("ATTR_NAME", attr.name_python)
                else:
                    line = line.replace("ATTR_NAME", attr.name_cpp)
                code = code + line + "\n"
        return code

    r = ""
    r += code_intro + "\n"
    r += "#ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"
    r += "\n"
    r += dump_attributes(True)
    r += "\n"
    r += "#else // #ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"
    r += "\n"
    r += dump_attributes(False)
    r += "\n"
    r += "#endif // #ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"

    r = r + code_outro
    return code_utils.indent_code_force(r, 8)


def make_struct_piy_code(struct_infos: StructInfos):
    code_intro = f'''class {struct_infos.struct_name()}:
    "{struct_infos.struct_code.one_line_title}"
    '''
    attr_inner = """    NAME_PYTHON: TYPE_PYTHON = DEFAULT_VALUE_PYTHON"""
    code_outro = ""

    r = code_intro + "\n";

    def add_line(l):
        nonlocal r
        r = r + l + "\n"

    for info in struct_infos.attr_and_regions:
        if info.code_region_comment is not None:
            add_line("")
            add_line("    #")
            for line in info.code_region_comment.comment.split("\n"):
                add_line("    # " + line)
            add_line("    #")

        if info.struct_attribute is not None:
            attr = info.struct_attribute
            for line in attr.comment.split("\n"):
                add_line("    # " + line)
            line = attr_inner
            line = line.replace("NAME_PYTHON", attr.name_python)
            line = line.replace("TYPE_PYTHON", code_utils.apply_code_replacements(attr.type))
            line = line.replace("DEFAULT_VALUE_PYTHON", code_utils.apply_code_replacements(attr.default_value))
            add_line(line)

    r = r + code_outro
    return r


def write_generated_code(
        struct_header_filename: str,
        struct_name: str,
        modified_cpp_filename: str,
        marker_id: str,
        code_generator_function,
        flag_preserve_left_spaces: bool
    ):
    struct_infos = extract_struct_infos(
        code_utils.read_text_file(struct_header_filename),
        struct_name)
    code_marker = f"{struct_name}.{marker_id}"
    generated_code = code_generator_function(struct_infos)
    code_utils.write_code_between_markers(
        modified_cpp_filename,
        code_marker,
        generated_code,
        flag_preserve_left_spaces
    )


def write_struct_attributes_pybindcpp_code(struct_header_filename, struct_name, modified_cpp_filename):
    write_generated_code(
        struct_header_filename, struct_name, modified_cpp_filename, "attributes", make_struct_attributes_cpp_code, False)


def write_struct_tostring_code(struct_header_filename, struct_name, modified_cpp_filename):
    write_generated_code(
        struct_header_filename, struct_name, modified_cpp_filename, "tostring", make_struct_tostring_cpp_code, False)


def write_struct_docstring(struct_header_filename, struct_name):
    modified_py_filename = THIS_DIR + "/../src_python/immvision/__init__.py"
    write_generated_code(
        struct_header_filename, struct_name, modified_py_filename, "docstring", make_struct_doc_code, True)


def write_struct_piy_code(struct_header_filename, struct_name):
    modified_py_filename = THIS_DIR + "/../src_python/immvision/cpp_immvision.pyi"
    write_generated_code(
        struct_header_filename, struct_name, modified_py_filename, "piy", make_struct_piy_code, True)



def main():
    struct_header_filename = f"{REPO_DIR}/src/immvision/image.h"

    # Good
    struct_names = ["ImageParams", "ColorAdjustmentsValues"]
    for struct_name in struct_names:
        modified_cpp_filename = f"{REPO_DIR}/pybind/src_cpp/pybind_image.cpp"
        write_struct_attributes_pybindcpp_code(
            struct_header_filename,
            struct_name,
            modified_cpp_filename
        )
        modified_cpp_filename = f"{REPO_DIR}/src/immvision/internal/misc/immvision_to_string.cpp"
        write_struct_tostring_code(
            struct_header_filename, struct_name, modified_cpp_filename)

        write_struct_docstring(struct_header_filename, struct_name)

        write_struct_piy_code(struct_header_filename, struct_name)

if __name__ == "__main__":
    main()
