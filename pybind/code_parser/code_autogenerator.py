"""
This file generates the autogenerated code in some cpp and pyi files.

Search for occurrences of
<autogen:ImageParams.attributes>
<autogen:ImageParams.tostring>
etc.
"""
import os
import typing
from dataclasses import dataclass, field


import code_utils


THIS_DIR = os.path.dirname(__file__)
REPO_DIR = os.path.realpath(THIS_DIR + "/../..")


@dataclass
class StructCode:
    struct_name: str = ""
    line_start: int = 0      # starting line of the struct in the whole code
    line_end: int = 0        # end line of the struct
    body_code: str = ""      # the code inside the struct body
    one_line_title: str = "" # the short title just one line before the struct declaration


@dataclass
class StructAttribute:
    name_cpp: str = ""
    name_python: str = ""
    type: str = ""
    default_value: str = ""
    comment: str = ""
    line_number: int = 0  # from the body_code line_start


@dataclass
class CodeRegionComment:
    """
    A CodeRegionComment is the beginning kind of "code region" inside a struct.
    It should look like this in the C++ header file:

    `````cpp
    //
    // Display size and title                                                <=== This is a CodeRegionComment
    // (the display size can differ from the image size)                     <=== It can span several lines
    //

    // Size of the displayed image (can be different from the matrix size)   <=== This is StructAttribute.comment
    cv::Size ImageDisplaySize = cv::Size();                                   (it should fit on one line)
    // Title displayed in the border
    std::string Legend = "Image";
    ````

    """
    comment: str = ""
    line_number: int = 0


@dataclass
class Variant_Attribute_CodeRegion:
    line_number: int = 0
    code_region_comment: CodeRegionComment = None
    struct_attribute: StructAttribute = None


class StructInfos:
    def __init__(self):
        self.struct_code: StructCode = None
        self.attr_and_regions = []

    def struct_name(self):
        return self.struct_code.struct_name


def _extract_struct_code(whole_file_code: str, struct_name: str) -> StructCode:
    """
    Very dumb code parser
    :return:
    * an extract of the code, which is the body of the struct
    * the line number where it starts
    """
    r = StructCode()
    r.struct_name = struct_name

    code_lines = whole_file_code.split("\n")

    def extract_one_line_title(line_number: int):
        if line_number == 0:
            return ""
        previous_line = code_lines[line_number - 1]
        if previous_line.strip().startswith("//"):
            return previous_line.strip()[2:].strip()
        return ""

    struct_lines = []
    in_struct = False
    nb_accolades = 0
    for line_number, code_line in enumerate(code_lines):
        if f"struct {struct_name}" in code_line:
            in_struct = True
            r.line_start = line_number
            r.one_line_title = extract_one_line_title(line_number)

        if "{" in code_line and in_struct:
            nb_accolades += 1

        if "}" in code_line and in_struct:
            nb_accolades -= 1
            if nb_accolades == 0:
                if in_struct:
                    r.line_end = line_number
                in_struct = False

        if nb_accolades > 0 and in_struct:
            struct_lines.append(code_line)

    if struct_lines[0].strip() == "{":
        struct_lines = struct_lines[1:]

    r.body_code = "\n".join(struct_lines)
    return r


def extract_struct_attributes(struct_code: StructCode) -> typing.List[StructAttribute]:
    """
    *Very* dumb parser, that works with our simple structs
    """
    code_lines = struct_code.body_code.split("\n")
    code_lines = map(lambda s: s.strip(), code_lines)
    numbered_code_lines = list(enumerate(code_lines))

    def is_attribute_line(nb_and_code_line) -> bool:
        code_line = nb_and_code_line[1]
        if code_line.startswith("//") or len(code_line) == 0:
            return False
        return True

    def parse_attribute(nb_and_code_line) -> StructAttribute:
        """
        Can handle lines like
            ColorAdjustmentsValues ColorAdjustments = ColorAdjustmentsValues();
        or
            std::vector <cv::Point> WatchedPixels;
        """
        line_number = nb_and_code_line[0]
        code_line = nb_and_code_line[1]

        r = StructAttribute()
        r.line_number = line_number
        code_line = code_line.strip()
        if code_line[-1] == ";":
            code_line = code_line[:-1]
        if "=" in code_line:
            equal_sides = code_line.split("=")
            r.default_value = equal_sides[1].strip()
            code_line = equal_sides[0].strip()
        if " " not in code_line:
            raise RuntimeError(f"can't parse attribute at line {code_line}")
        last_space_pos = code_line.rindex(" ")
        r.type = code_line[:last_space_pos].strip()
        r.name_cpp = code_line[last_space_pos:].strip()
        r.name_python = code_utils.to_snake_case(r.name_cpp)
        return r

    def add_attribute_comment(attribute: StructAttribute) -> str:
        # Search for comment beginning with // immediately on top of the attribute
        comment_lines_before_attribute_decl = []
        line_number = attribute.line_number - 1
        while line_number >= 0:
            previous_code_line: str = numbered_code_lines[line_number][1]
            if not previous_code_line.startswith("//"):
                break
            previous_code_line = previous_code_line[2:].strip()
            if len(previous_code_line) == 0:
                break
            comment_lines_before_attribute_decl.append(previous_code_line)
            line_number = line_number - 1
        comment_lines_before_attribute_decl = list(reversed(comment_lines_before_attribute_decl))
        attribute.comment = "\n".join(comment_lines_before_attribute_decl)
        # if no comment found on top, try to find one to the right? (YAGNI, this is a *simple* parser)

    attribute_lines = list(filter(is_attribute_line, numbered_code_lines))
    all_attributes = list(map(parse_attribute, attribute_lines))
    for attribute in all_attributes:
        add_attribute_comment(attribute)
    return all_attributes


def extract_code_region_comments(struct_code: StructCode) -> typing.List[CodeRegionComment]:
    """
    Code region comments look like this
    //
    // This is a code region comment.
    // It can have several lines, but needs to have an empty comment before and after
    //
    """
    code_lines = struct_code.body_code.split("\n")
    code_lines = map(lambda s: s.strip(), code_lines)
    numbered_code_lines = list(enumerate(code_lines))

    all_code_region_comments = []

    def get_code_line(line_number: int) -> str:
        return numbered_code_lines[line_number][1]

    def is_empty_comment(line_number):
        return get_code_line(line_number).strip() == "//"

    def is_filled_comment(line_number):
        c = get_code_line(line_number)
        return c.strip().startswith("//") and len(c[2:].strip()) > 0

    def get_filled_comment(line_number):
        assert (is_filled_comment(line_number))
        c = get_code_line(line_number)
        return c.strip()[2:]

    def append_line(str1, str2):
        if len(str1) == 0:
            return str2
        else:
            return str1 + "\n" + str2

    current_code_region_comment = None
    for line_number, code_line in numbered_code_lines:
        if is_empty_comment(line_number) and current_code_region_comment is None:
            current_code_region_comment = CodeRegionComment()
            current_code_region_comment.line_number = line_number
        elif is_empty_comment(line_number) and current_code_region_comment is not None:
            all_code_region_comments.append(current_code_region_comment)
            current_code_region_comment = None
        elif is_filled_comment(line_number) and current_code_region_comment is not None:
            current_code_region_comment.comment = \
                append_line(current_code_region_comment.comment, get_filled_comment(line_number))

    return all_code_region_comments


def extract_struct_infos(whole_code: str, struct_name: str) -> StructInfos:
    r = StructInfos()
    r.struct_code = _extract_struct_code(whole_code, struct_name)
    struct_attributes = extract_struct_attributes(r.struct_code)
    code_region_comments = extract_code_region_comments(r.struct_code)
    for sa in struct_attributes:
        v = Variant_Attribute_CodeRegion()
        v.line_number = sa.line_number
        v.struct_attribute = sa
        r.attr_and_regions.append(v)
    for cr in code_region_comments:
        v = Variant_Attribute_CodeRegion()
        v.line_number = cr.line_number
        v.code_region_comment = cr
        r.attr_and_regions.append(v)

    r.attr_and_regions = sorted(r.attr_and_regions, key=lambda x: x.line_number)
    return r


def make_struct_doc(struct_infos: StructInfos) -> str:
    doc = f"{struct_infos.struct_code.one_line_title}\n\n"

    for info in struct_infos.attr_and_regions:
        if info.code_region_comment is not None:
            doc = doc + "\n" + info.code_region_comment.comment + "\n"
        elif info.struct_attribute is not None:
            attr = info.struct_attribute
            attr_doc = f"{attr.name_python}: {attr.type}"
            if len(attr.default_value) > 0:
                attr_doc = attr_doc + " = " + attr.default_value

            if len(attr.comment) > 0:
                comment_lines = attr.comment.split("\n")
                comment_lines = map(lambda l: "            " + l, comment_lines)
                comment = "\n".join(comment_lines)
                attr_doc = attr_doc + "\n" + comment
            doc = doc + "    * " + attr_doc + "\n"

    doc = code_utils.apply_code_replacements(doc)
    return doc


def generate_init_python_code(struct_infos: StructInfos) -> str:
    """
    Should generate code that looks like this:

class ColorAdjustmentsValues(cpp_immvision.ColorAdjustmentsValues):
    '''
    {docstring}
    '''
    def __init__(
        self,
        # Pre-multiply values by a Factor before displaying
        factor : float=1.,
        # Add a delta to the values before displaying
        delta: float = 0.
    ):
        cpp_immvision.ColorAdjustmentsValues.__init__(self)
        self.factor = factor
        self.delta = delta


cpp_immvision.ColorAdjustmentsValues.__doc__ == "{docstring}"
    """


    struct_name = struct_infos.struct_name()
    docstring = make_struct_doc(struct_infos)

    code_intro  = f'''
class {struct_name}(cpp_immvision.{struct_name}):
    """{docstring}
    """
    
    def __init__(
        self,
'''

    code_inner_param = "        ATTR_NAME_PYTHON: ATTR_TYPE = ATTR_DEFAULT,\n"

    code_outro_1 = f"\n    ):\n        cpp_immvision.{struct_name}.__init__(self)\n"

    code_inner_set = "        self.ATTR_NAME_PYTHON = ATTR_NAME_PYTHON\n"

    # code_outro_2 = f'\n\ncpp_immvision.ColorAdjustmentsValues.__doc__ == """{docstring}"""\n\n'
    code_outro_2 = f'\n\n'

    def do_replace(s: str, attr: StructAttribute):
        out = s
        out = out.replace("ATTR_NAME_PYTHON", attr.name_python)
        out = out.replace("ATTR_TYPE", code_utils.apply_code_replacements(attr.type))
        out = out.replace("ATTR_DEFAULT", code_utils.apply_code_replacements(attr.default_value))
        return out

    def split_comment(comment: str):
        lines = comment.split("\n")
        out = ""
        for line in lines:
            out += "        # " + line + "\n"
        return out

    final_code = code_intro
    for info in struct_infos.attr_and_regions:
        if info.struct_attribute is not None:
            attr = info.struct_attribute
            final_code += split_comment(attr.comment)
            final_code += do_replace(code_inner_param, attr)
    final_code += code_outro_1
    for info in struct_infos.attr_and_regions:
        if info.struct_attribute is not None:
            attr = info.struct_attribute
            final_code += do_replace(code_inner_set, attr)
    final_code += code_outro_2

    return final_code



def generate_pydef_cpp_code(struct_infos: StructInfos) -> str:
    struct_name = struct_infos.struct_name()

    code_intro  = f'auto pyClass{struct_name} = py::class_<{struct_name}>(m, "{struct_name}") \n'
    code_intro += f'    .def(py::init<>()) \n'

    code_inner  = f'    .def_readwrite("ATTR_NAME_PYTHON", &{struct_name}::ATTR_NAME_CPP, "ATTR_COMMENT")\n'

    code_outro  = f'    .def("__repr__", [](const {struct_name}& v) {{ return ToString(v); }}); \n\n'

    r = code_intro
    for info in struct_infos.attr_and_regions:
        if info.struct_attribute is not None:
            attr = info.struct_attribute
            code = code_inner
            code = code.replace("ATTR_NAME_PYTHON", attr.name_python)
            code = code.replace("ATTR_NAME_CPP", attr.name_cpp)
            code = code.replace("ATTR_COMMENT", code_utils.escape_new_lines(attr.comment))
            r = r + code
    r = r + code_outro

    r = code_utils.indent_code(r, 4)

    return r


def generate_tostring_cpp_code(struct_infos: StructInfos) -> str:
    code_intro = f'''
    std::string ToString(const {struct_infos.struct_name()}& v)
    {{

        using namespace ImmVision::StringUtils;
        
        std::string r;
        r += "{struct_infos.struct_name()}\\n";
        r += "{{\\n";
    
        std::string inner;
'''

    code_inner = '        inner = inner + "ATTR_NAME: " + ToString(v.ATTR_NAME_CPP) + "\\n";'

    code_outro = f'''
        r = r + IndentLines(inner, 4);
        r += "}}";
        return r;
    }}
    '''

    def dump_attributes(is_python: bool):
        code = ""
        for info in struct_infos.attr_and_regions:
            if info.struct_attribute is not None:
                #         r = r + MakeIndent(indent_size) + "ColorAdjustments: " + ToString(v.ColorAdjustments) + "\n";
                attr = info.struct_attribute
                line = code_inner
                line = line.replace("ATTR_NAME_CPP", attr.name_cpp)
                if is_python:
                    line = line.replace("ATTR_NAME", attr.name_python)
                else:
                    line = line.replace("ATTR_NAME", attr.name_cpp)
                code = code + line + "\n"
        return code

    r = ""
    r += code_intro + "\n"
    r += "#ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"
    r += "\n"
    r += dump_attributes(True)
    r += "\n"
    r += "#else // #ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"
    r += "\n"
    r += dump_attributes(False)
    r += "\n"
    r += "#endif // #ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"

    r = r + code_outro
    return r


def generate_tostring_decl_h(struct_infos: StructInfos) -> str:
    return f"    std::string ToString(const {struct_infos.struct_name()}& params);\n"


def generate_pyi_python_code(struct_infos: StructInfos) -> str:
    code_intro = f'''class {struct_infos.struct_name()}:
    "{struct_infos.struct_code.one_line_title}"
    '''
    attr_inner = """    NAME_PYTHON: TYPE_PYTHON = DEFAULT_VALUE_PYTHON"""
    code_outro = "\n\n"

    r = code_intro + "\n";

    def add_line(l):
        nonlocal r
        r = r + l + "\n"

    for info in struct_infos.attr_and_regions:
        if info.code_region_comment is not None:
            add_line("")
            add_line("    #")
            for line in info.code_region_comment.comment.split("\n"):
                add_line("    # " + line)
            add_line("    #")

        if info.struct_attribute is not None:
            attr = info.struct_attribute
            for line in attr.comment.split("\n"):
                add_line("    # " + line)
            line = attr_inner
            line = line.replace("NAME_PYTHON", attr.name_python)
            line = line.replace("TYPE_PYTHON", code_utils.apply_code_replacements(attr.type))
            line = line.replace("DEFAULT_VALUE_PYTHON", code_utils.apply_code_replacements(attr.default_value))
            add_line(line)

    r = r + code_outro
    return r


@dataclass
class AutoGeneratedFile:
    filename: str = ""
    generator_type: str = ""
    generator_function:typing.Callable[[StructInfos], str] = None


def file_full_path(filename):
    return f"{REPO_DIR}/{filename}"


def main():
    input_header_file = "src/immvision/image.h"
    whole_header_cpp_code = code_utils.read_text_file(file_full_path(input_header_file))
    struct_names = ["ColorAdjustmentsValues", "MouseInformation", "ImageParams"]
    generated_files = [
        AutoGeneratedFile("pybind/src_cpp/pydef_image.cpp", "pydef", generate_pydef_cpp_code),
        AutoGeneratedFile("pybind/src_python/immvision/__init__.py", "init", generate_init_python_code),
        AutoGeneratedFile("pybind/src_python/immvision/cpp_immvision.pyi", "pyi", generate_pyi_python_code),
        AutoGeneratedFile("src/immvision/internal/misc/immvision_to_string.cpp", "tostring", generate_tostring_cpp_code),
        AutoGeneratedFile("src/immvision/internal/misc/immvision_to_string.h", "tostring_decl", generate_tostring_decl_h)
    ]

    for generated_file in generated_files:
        generated_code = ""
        for struct_name in struct_names:
            struct_infos = extract_struct_infos(whole_header_cpp_code, struct_name)

            generated_code += generated_file.generator_function(struct_infos)
            code_marker_in = f"<autogen:{generated_file.generator_type}>"
            code_marker_out = f"</autogen:{generated_file.generator_type}>"
            flag_preserve_left_spaces = True
            code_utils.write_code_between_markers(
                file_full_path(generated_file.filename),
                code_marker_in,
                code_marker_out,
                generated_code,
                flag_preserve_left_spaces
            )


if __name__ == "__main__":
    main()
