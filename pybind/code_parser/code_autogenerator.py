"""
This file generates the autogenerated code in some cpp and pyi files.

Search for occurrences of
<autogen:ImageParams.attributes>
<autogen:ImageParams.tostring>
etc.
"""
import os
import typing
from dataclasses import dataclass, field
from enum import Enum
import time


import code_utils


THIS_DIR = os.path.dirname(__file__)
REPO_DIR = os.path.realpath(THIS_DIR + "/../..")


class PydefType(Enum):
    STRUCT = "Struct"
    FUNCTION = "Function"


@dataclass
class PydefCode:
    name: str = ""
    title: str = ""          # the short title just one line before the struct or function declaration
    line_start: int = 0      # starting line of the struct or function in the whole code
    line_end: int = 0        # end line of the struct
    body_code: str = ""      # the code inside the struct body


@dataclass
class PydefAttribute:
    name_cpp: str = ""
    name_python: str = ""
    type: str = ""
    default_value: str = ""
    comment: str = ""
    line_number: int = 0  # from the body_code line_start


@dataclass
class CodeRegionComment:
    """
    A CodeRegionComment is the beginning kind of "code region" inside a struct.
    It should look like this in the C++ header file:

    `````cpp
    //
    // Display size and title                                                <=== This is a CodeRegionComment
    // (the display size can differ from the image size)                     <=== It can span several lines
    //

    // Size of the displayed image (can be different from the matrix size)   <=== This is StructAttribute.comment
    cv::Size ImageDisplaySize = cv::Size();                                   (it should fit on one line)
    // Title displayed in the border
    std::string Legend = "Image";
    ````

    """
    comment: str = ""
    line_number: int = 0


@dataclass
class Variant_Attribute_CodeRegion:
    line_number: int = 0
    code_region_comment: CodeRegionComment = None
    attribute: PydefAttribute = None


class StructInfos:
    def __init__(self):
        self.struct_code: PydefCode = None
        self.attr_and_regions = [] # list[Variant_Attribute_CodeRegion]

    def struct_name(self):
        return self.struct_code.name


@dataclass
class FunctionsInfos:
    function_code: PydefCode = None
    parameters = []  # list[PydefAttribute]

    def function_name(self):
        return self.function_code.name


def fetch_title_and_start_line(code_lines: list[str], line_nb: int) -> int :
    title_lines = []
    idx = line_nb + 1
    while idx < len(code_lines):
        line = code_lines[idx].strip()
        if not line.startswith("//"):
            break
        title_lines.append(line[2:])
        idx += 1
    title = "\n".join(title_lines)
    title = code_utils.apply_code_replacements(title)
    return title, idx


def fill_pydef_body_code(code_lines: list[str], pydef_type: PydefType, pydef_code_inout: PydefCode):
    body_lines = []
    lines_under_pydef = code_lines[pydef_code_inout.line_start:]
    flag_entered_body = False
    flag_exited_body = False


    if pydef_type == PydefType.STRUCT:
        opening_token = "{"
        closing_token = "}"
    elif pydef_type == PydefType.FUNCTION:
        opening_token = "("
        closing_token = ")"
    else:
        raise(f"fill_pydef_body_code: unsupported pydef_type {pydef_type}")

    nb_opening_tokens = 0

    def count_tokens(line):
        return line.count(opening_token) - line.count(closing_token)

    def append_body_line(line):
        if len(line) > 0:
            body_lines.append(line)

    for line_number, code_line in enumerate(lines_under_pydef):
        if flag_exited_body:
            break
        body_line = ""
        for character in code_line:
            nb_opening_tokens += count_tokens(character)
            if not flag_entered_body and nb_opening_tokens == 1:
                flag_entered_body = True
            if flag_entered_body and not flag_exited_body:
                body_line += character
            if nb_opening_tokens == 0 and flag_entered_body:
                flag_exited_body = True
                pydef_code_inout.line_end = line_number + pydef_code_inout.line_start
        append_body_line(body_line)

    pydef_code_inout.body_code = "\n".join(body_lines)[1:-1]


def find_pydefs_cpp(whole_file_code: str, pydef_type: PydefType) -> list[PydefCode]:
    def fn_extract_struct_name(line):
        if line.startswith("struct"):
            items = line.split(" ")
            cpp_name = items[1]
            return cpp_name
        else:
            raise RuntimeError(f"extract_struct_name{line} => no struct found!")

    def fn_extract_function_name(line: str):
        type_and_fn = line.split(" ")
        fn = type_and_fn[1]
        fn_name = fn[:fn.index("(")]
        return fn_name

    if pydef_type == PydefType.STRUCT:
        pydef_marker = "!pydef_struct"
        fn_extract_name = fn_extract_struct_name
    elif pydef_type == PydefType.FUNCTION:
        pydef_marker = "!pydef_function"
        fn_extract_name = fn_extract_function_name
    else:
        raise(f"find_pydefs_cpp: unsupported pydef_type {pydef_type}")

    code_lines = whole_file_code.split("\n")
    pydef_codes = []
    for line_number, code_line in enumerate(code_lines):
        if pydef_marker in code_line:
            pydef_code = PydefCode()
            pydef_code.title, pydef_code.line_start = fetch_title_and_start_line(code_lines, line_number)
            cpp_line = code_lines[pydef_code.line_start].strip()
            pydef_code.name = fn_extract_name(cpp_line)
            pydef_codes.append(pydef_code)

    for pydef_code in pydef_codes:
        fill_pydef_body_code(code_lines, pydef_type, pydef_code)
    return pydef_codes


def extract_struct_attributes(struct_code: PydefCode) -> typing.List[PydefAttribute]:
    """
    *Very* dumb parser, that works with our simple structs
    """
    code_lines = struct_code.body_code.split("\n")
    code_lines = map(lambda s: s.strip(), code_lines)
    numbered_code_lines = list(enumerate(code_lines))

    def is_attribute_line(nb_and_code_line) -> bool:
        code_line = nb_and_code_line[1]
        if code_line.startswith("//") or len(code_line.strip()) <= 2:
            return False
        return True

    def parse_attribute(nb_and_code_line) -> PydefAttribute:
        """
        Can handle lines like
            ColorAdjustmentsValues ColorAdjustments = ColorAdjustmentsValues();
        or
            std::vector <cv::Point> WatchedPixels;
        """
        line_number = nb_and_code_line[0]
        code_line = nb_and_code_line[1]

        r = PydefAttribute()
        r.line_number = line_number
        code_line = code_line.strip()
        if code_line[-1] == ";":
            code_line = code_line[:-1]
        if "=" in code_line:
            equal_sides = code_line.split("=")
            r.default_value = equal_sides[1].strip()
            code_line = equal_sides[0].strip()
        if " " not in code_line:
            raise RuntimeError(f"can't parse attribute at line {code_line}")
        last_space_pos = code_line.rindex(" ")
        r.type = code_line[:last_space_pos].strip()
        r.name_cpp = code_line[last_space_pos:].strip()
        r.name_python = code_utils.to_snake_case(r.name_cpp)
        return r

    def add_attribute_comment(attribute: PydefAttribute) -> str:
        # Search for comment beginning with // immediately on top of the attribute
        comment_lines_before_attribute_decl = []
        line_number = attribute.line_number - 1
        while line_number >= 0:
            previous_code_line: str = numbered_code_lines[line_number][1]
            if not previous_code_line.startswith("//"):
                break
            previous_code_line = previous_code_line[2:].strip()
            if len(previous_code_line) == 0:
                break
            comment_lines_before_attribute_decl.append(previous_code_line)
            line_number = line_number - 1
        comment_lines_before_attribute_decl = list(reversed(comment_lines_before_attribute_decl))
        attribute.comment = "\n".join(comment_lines_before_attribute_decl)
        # if no comment found on top, try to find one to the right? (YAGNI, this is a *simple* parser)

    attribute_lines = list(filter(is_attribute_line, numbered_code_lines))
    all_attributes = list(map(parse_attribute, attribute_lines))
    for attribute in all_attributes:
        add_attribute_comment(attribute)
    return all_attributes


def extract_code_region_comments(struct_code: PydefCode) -> typing.List[CodeRegionComment]:
    """
    Code region comments look like this
    //
    // This is a code region comment.
    // It can have several lines, but needs to have an empty comment before and after
    //
    """
    code_lines = struct_code.body_code.split("\n")
    code_lines = map(lambda s: s.strip(), code_lines)
    numbered_code_lines = list(enumerate(code_lines))

    all_code_region_comments = []

    def get_code_line(line_number: int) -> str:
        return numbered_code_lines[line_number][1]

    def is_empty_comment(line_number):
        return get_code_line(line_number).strip() == "//"

    def is_filled_comment(line_number):
        c = get_code_line(line_number)
        return c.strip().startswith("//") and len(c[2:].strip()) > 0

    def get_filled_comment(line_number):
        assert (is_filled_comment(line_number))
        c = get_code_line(line_number)
        return c.strip()[2:]

    def append_line(str1, str2):
        if len(str1) == 0:
            return str2
        else:
            return str1 + "\n" + str2

    current_code_region_comment = None
    for line_number, code_line in numbered_code_lines:
        if is_empty_comment(line_number) and current_code_region_comment is None:
            current_code_region_comment = CodeRegionComment()
            current_code_region_comment.line_number = line_number
        elif is_empty_comment(line_number) and current_code_region_comment is not None:
            all_code_region_comments.append(current_code_region_comment)
            current_code_region_comment = None
        elif is_filled_comment(line_number) and current_code_region_comment is not None:
            current_code_region_comment.comment = \
                append_line(current_code_region_comment.comment, get_filled_comment(line_number))

    return all_code_region_comments


def extract_struct_infos(pydef_code: PydefCode) -> StructInfos:
    r = StructInfos()
    r.struct_code = pydef_code
    struct_attributes = extract_struct_attributes(r.struct_code)
    code_region_comments = extract_code_region_comments(r.struct_code)
    for sa in struct_attributes:
        v = Variant_Attribute_CodeRegion()
        v.line_number = sa.line_number
        v.attribute = sa
        r.attr_and_regions.append(v)
    for cr in code_region_comments:
        v = Variant_Attribute_CodeRegion()
        v.line_number = cr.line_number
        v.code_region_comment = cr
        r.attr_and_regions.append(v)

    r.attr_and_regions = sorted(r.attr_and_regions, key=lambda x: x.line_number)
    return r


def extract_function_infos(pydef_code: PydefCode) -> FunctionsInfos:
    r = FunctionsInfos()
    r.function_code = pydef_code
    r.parameters = extract_function_parameters(pydef_code)
    return r


def make_struct_doc(struct_infos: StructInfos) -> str:
    doc = f"{struct_infos.struct_code.title}\n\n"

    for info in struct_infos.attr_and_regions:
        if info.code_region_comment is not None:
            doc = doc + "\n" + code_utils.apply_code_replacements(info.code_region_comment.comment) + "\n"
        elif info.attribute is not None:
            attr = info.attribute
            attr_doc = f"{attr.name_python}: {code_utils.apply_code_replacements(attr.type)}"
            if len(attr.default_value) > 0:
                attr_doc = attr_doc + " = " + code_utils.apply_code_replacements(attr.default_value)

            if len(attr.comment) > 0:
                comment_lines = attr.comment.split("\n")
                comment_lines = map(lambda l: "            " + l, comment_lines)
                comment = "\n".join(comment_lines)
                attr_doc = attr_doc + "\n" + code_utils.apply_code_replacements(comment)
            doc = doc + "    * " + attr_doc + "\n"

    return doc


def extract_function_parameters(pydef_code: PydefCode) -> typing.List[PydefAttribute]:
    """
    can parse a string like:
        const cv::Mat& image,
        const cv::Size& imageDisplaySize = cv::Size(),
        bool refreshImage = false,
        bool showOptions = true,
        bool isBgrOrBgra = true
    """
    parameters_strs = pydef_code.body_code.split(",")
    parameters_strs = map(lambda s: s.strip(), parameters_strs)
    parameters_strs = list(filter(lambda s: len(s) > 0, parameters_strs))

    def parse_one_function_parameter(s: str) -> PydefAttribute:
        param = PydefAttribute()
        if "=" in s:
            items = s.split("=")
            if len(items) > 2:
                raise RuntimeError(f"parse_one_function_parameter({s}): expected at most on = sign")
            param.default_value = items[1].strip()
            s = items[0].strip()
        if " " not in s:
            raise RuntimeError(f"parse_one_function_parameter({s}): expected at least one space")
        last_space_pos = s.rindex(" ")
        param.type = s[:last_space_pos]
        param.name_cpp = s[last_space_pos + 1:]
        param.name_python = code_utils.to_snake_case(param.name_cpp)
        return param

    all_parameters = list(map(parse_one_function_parameter, parameters_strs))
    return all_parameters


def generate_init_struct_python_code(struct_infos: StructInfos) -> str:
    """
    Should generate code that looks like this:

class ColorAdjustmentsValues(cpp_immvision.ColorAdjustmentsValues):
    '''
    {docstring}
    '''
    def __init__(
        self,
        # Pre-multiply values by a Factor before displaying
        factor : float=1.,
        # Add a delta to the values before displaying
        delta: float = 0.
    ):
        cpp_immvision.ColorAdjustmentsValues.__init__(self)
        self.factor = factor
        self.delta = delta


cpp_immvision.ColorAdjustmentsValues.__doc__ == "{docstring}"
    """


    struct_name = struct_infos.struct_name()
    docstring = make_struct_doc(struct_infos)

    code_intro  = f'''
class {struct_name}(cpp_immvision.{struct_name}):
    """{docstring}
    """
    
    def __init__(
        self,
'''

    code_inner_param = "        ATTR_NAME_PYTHON: ATTR_TYPE = ATTR_DEFAULT,\n"
    code_outro_1 = f"\n    ):\n        cpp_immvision.{struct_name}.__init__(self)\n"
    code_inner_set = "        self.ATTR_NAME_PYTHON = ATTR_NAME_PYTHON\n"
    code_outro_2 = f'\n\n'

    def do_replace(s: str, attr: PydefAttribute):
        out = s
        out = out.replace("ATTR_NAME_PYTHON", attr.name_python)
        out = out.replace("ATTR_TYPE", code_utils.apply_code_replacements(attr.type))
        out = out.replace("ATTR_DEFAULT", code_utils.apply_code_replacements(attr.default_value))
        return out

    def split_comment(comment: str):
        lines = comment.split("\n")
        out = ""
        for line in lines:
            out += "        # " + line + "\n"
        return out

    final_code = code_intro
    for info in struct_infos.attr_and_regions:
        if info.attribute is not None:
            attr = info.attribute
            final_code += split_comment(attr.comment)
            final_code += do_replace(code_inner_param, attr)
    final_code += code_outro_1
    for info in struct_infos.attr_and_regions:
        if info.attribute is not None:
            attr = info.attribute
            final_code += do_replace(code_inner_set, attr)
    final_code += code_outro_2

    return final_code


def generate_init_function_python_code(function_infos: FunctionsInfos) -> str:
    """
    Should generate code like this:

    def image_display(
        np.ndarray image,
        Size image_display_size = (0, 0),
        refresh_image = False
        ):
        '''Only, display the image, with no decoration, and no user interaction


        '''
        cpp_immvision.image_display(image, image_display_size, refresh_image)
    """
    py_function_name = code_utils.to_snake_case(function_infos.function_name())
    title = code_utils.indent_code(function_infos.function_code.title, 4)[4:]

    code_intro = f'def {py_function_name}(\n'
    param_line_template  = f'PARAM_NAME: PARAM_TYPE PARAM_DEFAULT'
    code_outro = f'):\n    """{title}\n    """\n'

    r = code_intro
    param_lines = []
    for param in function_infos.parameters:
        param_line = param_line_template
        param_line = param_line.replace("PARAM_TYPE", code_utils.apply_code_replacements(param.type))
        param_line = param_line.replace("PARAM_NAME", param.name_python)
        if len(param.default_value) > 0:
            param_line = param_line.replace("PARAM_DEFAULT", " = "
                                            + code_utils.apply_code_replacements(param.default_value))
        else:
            param_line = param_line.replace(" PARAM_DEFAULT", "")
        param_lines.append(param_line.strip())
    params_str = ",\n".join(param_lines)
    params_str = code_utils.indent_code(params_str, 4)
    r = r + params_str

    r = r + code_outro

    r = r + "\n    cpp_immvision.transfer_imgui_context_python_to_cpp()\n\n"
    r = r + f"    r = cpp_immvision.{py_function_name}("
    params_list = []
    for param in function_infos.parameters:
        params_list.append(param.name_python)
    r = r + ", ".join(params_list)

    r = r + ")\n"
    r = r + '    return r\n'

    r = r + "\n\n"
    return r


def generate_pydef_struct_cpp_code(struct_infos: StructInfos) -> str:
    struct_name = struct_infos.struct_name()

    code_intro  = f'auto pyClass{struct_name} = py::class_<{struct_name}>(m, "{struct_name}") \n'
    code_intro += f'    .def(py::init<>()) \n'

    code_inner  = f'    .def_readwrite("ATTR_NAME_PYTHON", &{struct_name}::ATTR_NAME_CPP, "ATTR_COMMENT")\n'

    code_outro  = f'    .def("__repr__", [](const {struct_name}& v) {{ return ToString(v); }}); \n\n'

    r = code_intro
    for info in struct_infos.attr_and_regions:
        if info.attribute is not None:
            attr = info.attribute
            code = code_inner
            code = code.replace("ATTR_NAME_PYTHON", attr.name_python)
            code = code.replace("ATTR_NAME_CPP", attr.name_cpp)
            code = code.replace("ATTR_COMMENT", code_utils.escape_new_lines(attr.comment))
            r = r + code
    r = r + code_outro

    r = code_utils.indent_code(r, 4)

    return r


def generate_pydef_function_cpp_code(function_infos: FunctionsInfos) -> str:
    fn_name_python = code_utils.to_snake_case(function_infos.function_name())
    fn_name_cpp = function_infos.function_name()
    title = function_infos.function_code.title.replace("\n", "\\n")
    s = f'        m.def("{fn_name_python}", ImmVision::{fn_name_cpp}, "{title}");\n'
    return s


def generate_tostring_cpp_code(struct_infos: StructInfos) -> str:
    code_intro = f'''
    std::string ToString(const {struct_infos.struct_name()}& v)
    {{

        using namespace ImmVision::StringUtils;
        
        std::string r;
        r += "{struct_infos.struct_name()}\\n";
        r += "{{\\n";
    
        std::string inner;
'''

    code_inner = '        inner = inner + "ATTR_NAME: " + ToString(v.ATTR_NAME_CPP) + "\\n";'

    code_outro = f'''
        r = r + IndentLines(inner, 4);
        r += "}}";
        return r;
    }}
    '''

    def dump_attributes(is_python: bool):
        code = ""
        for info in struct_infos.attr_and_regions:
            if info.attribute is not None:
                #         r = r + MakeIndent(indent_size) + "ColorAdjustments: " + ToString(v.ColorAdjustments) + "\n";
                attr = info.attribute
                line = code_inner
                line = line.replace("ATTR_NAME_CPP", attr.name_cpp)
                if is_python:
                    line = line.replace("ATTR_NAME", attr.name_python)
                else:
                    line = line.replace("ATTR_NAME", attr.name_cpp)
                code = code + line + "\n"
        return code

    r = ""
    r += code_intro + "\n"
    r += "#ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"
    r += "\n"
    r += dump_attributes(True)
    r += "\n"
    r += "#else // #ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"
    r += "\n"
    r += dump_attributes(False)
    r += "\n"
    r += "#endif // #ifdef IMMVISION_BUILD_PYTHON_BINDINGS\n"

    r = r + code_outro
    return r


def generate_tostring_decl_h(struct_infos: StructInfos) -> str:
    return f"    std::string ToString(const {struct_infos.struct_name()}& params);\n"


def generate_pyi_python_code(struct_infos: StructInfos) -> str:
    code_intro = f'''class {struct_infos.struct_name()}:
    "{struct_infos.struct_code.title}"
    '''
    attr_inner = """    NAME_PYTHON: TYPE_PYTHON = DEFAULT_VALUE_PYTHON"""
    code_outro = "\n\n"

    r = code_intro + "\n";

    def add_line(l):
        nonlocal r
        r = r + l + "\n"

    for info in struct_infos.attr_and_regions:
        if info.code_region_comment is not None:
            add_line("")
            add_line("    #")
            for line in info.code_region_comment.comment.split("\n"):
                add_line("    # " + line)
            add_line("    #")

        if info.attribute is not None:
            attr = info.attribute
            for line in attr.comment.split("\n"):
                add_line("    # " + line)
            line = attr_inner
            line = line.replace("NAME_PYTHON", attr.name_python)
            line = line.replace("TYPE_PYTHON", code_utils.apply_code_replacements(attr.type))
            line = line.replace("DEFAULT_VALUE_PYTHON", code_utils.apply_code_replacements(attr.default_value))
            add_line(line)

    r = r + code_outro
    return r


@dataclass
class AutoGeneratedFile_StructInfos:
    filename: str = ""
    generator_type: str = ""
    generator_function:typing.Callable[[StructInfos], str] = None


@dataclass
class AutoGeneratedFile_FunctionsInfos:
    filename: str = ""
    generator_type: str = ""
    generator_function:typing.Callable[[FunctionsInfos], str] = None


def file_full_path(filename):
    return f"{REPO_DIR}/{filename}"


def code_autogenerator():
    start = time.time()

    input_header_file = "src/immvision/image.h"
    whole_header_cpp_code = code_utils.read_text_file(file_full_path(input_header_file))

    #
    # Generate structs code
    #
    pydef_codes_structs = find_pydefs_cpp(whole_header_cpp_code, PydefType.STRUCT)
    generated_files_structs = [
        AutoGeneratedFile_StructInfos("pybind/src_cpp/pydef_image.cpp", "pydef_struct", generate_pydef_struct_cpp_code),
        AutoGeneratedFile_StructInfos("pybind/src_python/immvision/__init__.py", "init_struct", generate_init_struct_python_code),
        AutoGeneratedFile_StructInfos("pybind/src_python/immvision/cpp_immvision.pyi", "pyi", generate_pyi_python_code),
        AutoGeneratedFile_StructInfos("src/immvision/internal/misc/immvision_to_string.cpp", "tostring", generate_tostring_cpp_code),
        AutoGeneratedFile_StructInfos("src/immvision/internal/misc/immvision_to_string.h", "tostring_decl", generate_tostring_decl_h)
    ]

    for generated_file in generated_files_structs:
        generated_code = ""

        for pydef_code_struct in pydef_codes_structs:
            struct_infos = extract_struct_infos(pydef_code_struct)
            generated_code += generated_file.generator_function(struct_infos)

        code_marker_in = f"<autogen:{generated_file.generator_type}>"
        code_marker_out = f"</autogen:{generated_file.generator_type}>"
        flag_preserve_left_spaces = True
        code_utils.write_code_between_markers(
            file_full_path(generated_file.filename),
            code_marker_in,
            code_marker_out,
            generated_code,
            flag_preserve_left_spaces
        )


    #
    # Generate functions code
    #
    pydef_codes_functions = find_pydefs_cpp(whole_header_cpp_code, PydefType.FUNCTION)
    generated_files_functions = [
        AutoGeneratedFile_FunctionsInfos("pybind/src_cpp/pydef_image.cpp", "pydef_function", generate_pydef_function_cpp_code),
        AutoGeneratedFile_StructInfos("pybind/src_python/immvision/__init__.py", "init_function", generate_init_function_python_code),
    ]
    for generated_file in generated_files_functions:
        generated_code = ""

        for pydef_code_function in pydef_codes_functions:
            function_infos = extract_function_infos(pydef_code_function)
            generated_code += generated_file.generator_function(function_infos)

        code_marker_in = f"<autogen:{generated_file.generator_type}>"
        code_marker_out = f"</autogen:{generated_file.generator_type}>"
        flag_preserve_left_spaces = True
        code_utils.write_code_between_markers(
            file_full_path(generated_file.filename),
            code_marker_in,
            code_marker_out,
            generated_code,
            flag_preserve_left_spaces
        )
    elapsed = time.time() - start
    print(f"  code_autogenerator (took {elapsed:.2f}s)")


if __name__ == "__main__":
    code_autogenerator()
